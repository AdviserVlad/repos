// Задание 2:
// Даны два массива : А[M] и B[N](M и N вводятся с клавиатуры).Необходимо создать третий
// массив минимально возможного размера, в котором нужно собрать элементы массивов A и B,
// которые не являются общими для них, без повторений


#include <iostream>
#include <conio.h>

using namespace std;
// Прототипы функций:
// Вывод названия задачи на экран
void printHead();

// Получение значения от пользователя
int getValue();

// Заполнение массива случайными числами
void initArray(int*, const int*);

// Вывод массива на экран
void printArray(int*, const int*);

// Вычисление размера третьего массива
int calculateArraySize(int*, int*, const int*, const int*);

// Проверка элементов массива на "уникальность"
bool searchForUniqueElements(int*, int*, const int*, const int*, int);

// Заполнение третьего массива "уникальными" значениями из первых двух массивов
void fillInTheThirdArray(int*, int*, int*, const int*, const int*, const int*);

int main()
{
    setlocale(LC_ALL, "RUS");
    srand(time(NULL));

    cout << "Задание 2:\n"
        "Даны два массива : А[M] и B[N](M и N вводятся с клавиатуры).Необходимо создать третий\n"
        "массив минимально возможного размера, в котором нужно собрать элементы массивов A и B\n"
        "которые не являются общими для них, без повторений.\n" << endl;

    cout << "Для начала работы нажмите любую клавишу...";
    _getch();
    system("cls");

    int size1,    // Размер первого массива
        size2,    // Размер второго массива
        size3;    // Размер третьего массива

    // Ограничение в 50 элементов выставлено для удобства (контроль реализован в вызываемой функции getValue)
    printHead();
    cout << "Введите размер массива 1 (не более 50)." << endl;
    size1 = getValue();

    printHead();
    cout << "Введите размер массива 2 (не более 50)." << endl;
    size2 = getValue();

    int* arr1 = new int[size1];     // Первый динамический массив
    int* arr2 = new int[size2];     // Второй динамический массив
    int* arr3;                      // На данном этапе только объявляется указатель
    // Изначально создал массив по итогу расчётов в ветке if-else (см. ниже). Но в таком случае он становится локальным в рамках else
    // и, соотетсвенно, delete[] данного массива будет возможен тоже только в рамках else. 

    initArray(arr1, &size1);
    initArray(arr2, &size2);

    // Вычисляем размер третьего массива и затем выводим все результаты работы программы на экран
    size3 = calculateArraySize(arr1, arr2, &size1, &size2);

    printHead();
    cout << "Размер массива 1: " << size1 << endl;
    cout << "Размер массива 2: " << size2 << endl;
    cout << "Размер массива 3: " << size3 << endl;

    cout << "\nПервый массив:" << endl;
    printArray(arr1, &size1);
    cout << "\n\nВторой массив:" << endl;
    printArray(arr2, &size2);
    cout << endl;

    if (size3 == 0)
    {
        cout << "\nВ данных массивах нет уникальных элементов!\n" << endl;
    }
    else
    {
        arr3 = new int[size3];
        fillInTheThirdArray(arr1, arr2, arr3, &size1, &size2, &size3);
        cout << "\nТретий массив:" << endl;
        printArray(arr3, &size3);
    }


    delete[] arr1, arr2, arr3;
    arr1 = arr2 = arr3 = nullptr;   // Есть ли смысл это делать, учитываея, что на следующей строчке пограмма завершается?

    cout << "\n\n******************************************************************************************************\n" << endl;


}

// Функция вызывается лишь пару раз, она больше для удобства чтения main
inline void printHead()
{
    system("cls");
    cout << "---------------------- Создание массива из уникальных чисел двух других массивов ----------------------\n" << endl;
}

// Получаем от пользователя значение, проверяем на корректность ввода и (если всё хорошо) возвращаем полученное значение в main
int getValue()
{
    int size;
    while (1)
    {
        cout << ">> ";
        cin >> size;
        if (cin.fail() || size < 1 || size > 50)
        {
            cin.clear();
            cin.ignore(32767, '\n');
            cout << "Некорректный ввод. Попробуйте ещё раз." << endl;
        }
        else
        {
            return size;
        }
    }
}

// Циклом запоняем массив рандомными числами от 0 до 20. Арифметика указателей - для практики :)
void initArray(int* arr, const int* size)
{
    for (int* ptr = arr; ptr < arr + *size; ++ptr)
    {
        *ptr = rand() % 21;
    }
}

// Циклом выводим массив на экран. Арифметика указателей - для практики :) Для вывода оказалась менее удобной, т.к. пришлось добавлять i для
// симпатичного вывода в несколько строк (больших массивов)
void printArray(int* arr, const int* size)
{
    for (int* ptr = arr, i = 0; ptr < arr + *size; ++ptr, ++i)
    {
        if (i % 10 == 0)
        {
            cout << endl;
        }
        cout << *ptr << "\t";
    }
}

// Находим в каждом массиве "уникальные" (т.е. которые НЕ являются общими для двух массивов) числа.
// При каждом таком найденном числе увеличиваем size3 на 1. Алгоритм посиска расписан в комментарии для функции searchForUniqueElements
// Для того, чтобы реализовать поиск в каждом массиве, вызываем одну и ту же функцию, но меняем местами аргументы, т.е.
// для проверки первого массива он и в функцию передаётся первым аргументом. Если проверяется второй массив - тогда уже он (второй) передаётся первым аргуметном.
// Аналогично меняются местами и их размеры
int calculateArraySize(int* arr1, int* arr2, const int* size1, const int* size2)
{
    int size3 = 0;
    for (int i = 0; i < *size1; i++)
    {
        if (searchForUniqueElements(arr1, arr2, size1, size2, i))
        {
            ++size3;
        }
    }

    for (int i = 0; i < *size2; i++)
    {
        if (searchForUniqueElements(arr2, arr1, size2, size1, i))
        {
            ++size3;
        }
    }
    return size3;
}


// Алгоритм следующий:
// Функция получает индекс элемента и начинает от этого элемента поиск такого же числа. Если "впереди" есть такой же элемент -
// функция сразу возвращает false. Она всё равно потом проверит это число на "уникальность", но только когда доберётся до пследней "копии". 
// Т.о. мы исключаем повторение "уникальных" чисел в третьем массиве.
// Если в первом массиве элементов с таким значением больше нет (или это последняя "копия"), то начинаем искать совпадения с элементами второго массива.
// Если попалось такое же число - сразу возвращаем false. Если таких чисел нет - значит элемент "уникальный" - возвращаем true.
bool searchForUniqueElements(int* arr1, int* arr2, const int* size1, const int* size2, int i = 0)
{

    for (int k = i + 1; k < *size1; ++k)
    {
        if (arr1[i] == arr1[k])
        {
            return false;
        }
    }

    for (int j = 0; j < *size2; ++j)
    {
        if (arr1[i] == arr2[j])
        {
            return false;
        }

    }
    return true;
}

// Заполняем массив "уникальными" числами. Ищем их аналогично тому процессу, который реализован для вычисления размера третьего массива,
// только вместо инкремента size3 просто вносим значение проверяемого элемента в третий массив.
void fillInTheThirdArray(int* arr1, int* arr2, int* arr3, const int* size1, const int* size2, const int* size3)
{
    int k = 0;  // Переменная для движения по третьему массиву
    for (int i = 0; i < *size1; ++i)
    {
        if (searchForUniqueElements(arr1, arr2, size1, size2, i))
        {
            arr3[k] = arr1[i];
            ++k;
        }
    }

    for (int i = 0; i < *size2; ++i)
    {
        if (searchForUniqueElements(arr2, arr1, size2, size1, i))
        {
            arr3[k] = arr2[i];
            ++k;
        }
    }
}
